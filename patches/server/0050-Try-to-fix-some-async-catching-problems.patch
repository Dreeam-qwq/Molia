From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MrHua269 <wangxyper@163.com>
Date: Thu, 13 Jul 2023 15:58:19 +0800
Subject: [PATCH] Try to fix some async catching problems


diff --git a/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
index 3208d68c0e8220307028acd4bcd859465611f992..fd585a0587d7ce2f6a766b55b27cf93c937f57ab 100644
--- a/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
+++ b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
@@ -490,7 +490,9 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
 
     private ChunkEntitySlices moveEntity(final Entity entity) {
         // ensure we own the entity
-        TickThread.ensureTickThread(entity, "Cannot move entity off-main");
+        //Molia start - Remove this async catcher
+        //TickThread.ensureTickThread(entity, "Cannot move entity off-main");
+        //Molia end
 
         final BlockPos newPos = entity.blockPosition();
         final int newSectionX = newPos.getX() >> 4;
@@ -501,11 +503,15 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
             return null;
         }
 
+        //Molia start - Do not ensure the tick thread because the entity may have a large move range
+        /*
         // ensure the new section is owned by this tick thread
         TickThread.ensureTickThread(this.world, newSectionX, newSectionZ, "Cannot move entity off-main");
 
         // ensure the old section is owned by this tick thread
         TickThread.ensureTickThread(this.world, entity.sectionX, entity.sectionZ, "Cannot move entity off-main");
+         */
+        //Molia end
 
         final ChunkEntitySlices old = this.getChunk(entity.sectionX, entity.sectionZ);
         final ChunkEntitySlices slices = this.getOrCreateChunk(newSectionX, newSectionZ);
diff --git a/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java b/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
index ce449b7b6f615f2c8240e4207f06d4e54ae0083e..ad84033391c9e2e44aa3e0c0133d0627e752725c 100644
--- a/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
+++ b/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
@@ -23,7 +23,9 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.locks.StampedLock;
 import java.util.function.Predicate;
+import java.util.function.Supplier;
 
 public final class ChunkEntitySlices {
 
@@ -52,6 +54,33 @@ public final class ChunkEntitySlices {
 
     // TODO implement container search optimisations
 
+    //Molia start - Locks for removed async catchers
+    private final StampedLock accessLock = new StampedLock();
+
+    private <T> T lockedOptiReadCode(Supplier<T> action){
+        long stamp = this.accessLock.tryOptimisticRead();
+        if (this.accessLock.validate(stamp)){
+            return action.get();
+        }
+
+        stamp = this.accessLock.readLock();
+        try {
+            return action.get();
+        }finally {
+            this.accessLock.unlockRead(stamp);
+        }
+    }
+
+    private <T> T lockedWriteCode(Supplier<T> action){
+        long stamp = this.accessLock.writeLock();
+        try {
+            return action.get();
+        }finally {
+            this.accessLock.unlockWrite(stamp);
+        }
+    }
+    //Molia end
+
     public ChunkEntitySlices(final ServerLevel world, final int chunkX, final int chunkZ, final FullChunkStatus status,
                              final int minSection, final int maxSection) { // inclusive, inclusive
         this.minSection = minSection;
@@ -69,83 +98,91 @@ public final class ChunkEntitySlices {
 
     // Paper start - optimise CraftChunk#getEntities
     public org.bukkit.entity.Entity[] getChunkEntities() {
-        List<org.bukkit.entity.Entity> ret = new java.util.ArrayList<>();
-        final Entity[] entities = this.entities.getRawData();
-        for (int i = 0, size = Math.min(entities.length, this.entities.size()); i < size; ++i) {
-            final Entity entity = entities[i];
-            if (entity == null) {
-                continue;
-            }
-            final org.bukkit.entity.Entity bukkit = entity.getBukkitEntity();
-            if (bukkit != null && bukkit.isValid()) {
-                ret.add(bukkit);
+        return this.lockedOptiReadCode(()->{
+            List<org.bukkit.entity.Entity> ret = new java.util.ArrayList<>();
+            final Entity[] entities = this.entities.getRawData();
+            for (int i = 0, size = Math.min(entities.length, this.entities.size()); i < size; ++i) {
+                final Entity entity = entities[i];
+                if (entity == null) {
+                    continue;
+                }
+                final org.bukkit.entity.Entity bukkit = entity.getBukkitEntity();
+                if (bukkit != null && bukkit.isValid()) {
+                    ret.add(bukkit);
+                }
             }
-        }
 
-        return ret.toArray(new org.bukkit.entity.Entity[0]);
+            return ret.toArray(new org.bukkit.entity.Entity[0]);
+        });
     }
 
     public CompoundTag save() {
-        final int len = this.entities.size();
-        if (len == 0) {
-            return null;
-        }
+        return this.lockedOptiReadCode(()->{
+            final int len = this.entities.size();
+            if (len == 0) {
+                return null;
+            }
 
-        final Entity[] rawData = this.entities.getRawData();
-        final List<Entity> collectedEntities = new ArrayList<>(len);
-        for (int i = 0; i < len; ++i) {
-            final Entity entity = rawData[i];
-            if (entity.shouldBeSaved()) {
-                collectedEntities.add(entity);
+            final Entity[] rawData = this.entities.getRawData();
+            final List<Entity> collectedEntities = new ArrayList<>(len);
+            for (int i = 0; i < len; ++i) {
+                final Entity entity = rawData[i];
+                if (entity.shouldBeSaved()) {
+                    collectedEntities.add(entity);
+                }
             }
-        }
 
-        if (collectedEntities.isEmpty()) {
-            return null;
-        }
+            if (collectedEntities.isEmpty()) {
+                return null;
+            }
 
-        return EntityStorage.saveEntityChunk(collectedEntities, new ChunkPos(this.chunkX, this.chunkZ), this.world);
+            return EntityStorage.saveEntityChunk(collectedEntities, new ChunkPos(this.chunkX, this.chunkZ), this.world);
+        });
     }
 
     // returns true if this chunk has transient entities remaining
     public boolean unload() {
-        final int len = this.entities.size();
-        final Entity[] collectedEntities = Arrays.copyOf(this.entities.getRawData(), len);
-
-        for (int i = 0; i < len; ++i) {
-            final Entity entity = collectedEntities[i];
-            if (entity.isRemoved()) {
-                // removed by us below
-                continue;
-            }
-            if (entity.shouldBeSaved()) {
-                entity.setRemoved(Entity.RemovalReason.UNLOADED_TO_CHUNK);
-                if (entity.isVehicle()) {
-                    // we cannot assume that these entities are contained within this chunk, because entities can
-                    // desync - so we need to remove them all
-                    for (final Entity passenger : entity.getIndirectPassengers()) {
-                        passenger.setRemoved(Entity.RemovalReason.UNLOADED_TO_CHUNK);
+        return this.lockedOptiReadCode(()->{
+            final int len = this.entities.size();
+            final Entity[] collectedEntities = Arrays.copyOf(this.entities.getRawData(), len);
+
+            for (int i = 0; i < len; ++i) {
+                final Entity entity = collectedEntities[i];
+                if (entity.isRemoved()) {
+                    // removed by us below
+                    continue;
+                }
+                if (entity.shouldBeSaved()) {
+                    entity.setRemoved(Entity.RemovalReason.UNLOADED_TO_CHUNK);
+                    if (entity.isVehicle()) {
+                        // we cannot assume that these entities are contained within this chunk, because entities can
+                        // desync - so we need to remove them all
+                        for (final Entity passenger : entity.getIndirectPassengers()) {
+                            passenger.setRemoved(Entity.RemovalReason.UNLOADED_TO_CHUNK);
+                        }
                     }
                 }
             }
-        }
 
-        return this.entities.size() != 0;
+            return this.entities.size() != 0;
+        });
     }
 
     private List<Entity> getAllEntities() {
-        final int len = this.entities.size();
-        if (len == 0) {
-            return new ArrayList<>();
-        }
+        return this.lockedOptiReadCode(()->{
+            final int len = this.entities.size();
+            if (len == 0) {
+                return new ArrayList<>();
+            }
 
-        final Entity[] rawData = this.entities.getRawData();
-        final List<Entity> collectedEntities = new ArrayList<>(len);
-        for (int i = 0; i < len; ++i) {
-            collectedEntities.add(rawData[i]);
-        }
+            final Entity[] rawData = this.entities.getRawData();
+            final List<Entity> collectedEntities = new ArrayList<>(len);
+            for (int i = 0; i < len; ++i) {
+                collectedEntities.add(rawData[i]);
+            }
 
-        return collectedEntities;
+            return collectedEntities;
+        });
     }
 
     public void callEntitiesLoadEvent() {
@@ -158,15 +195,20 @@ public final class ChunkEntitySlices {
     // Paper end - optimise CraftChunk#getEntities
 
     public boolean isEmpty() {
-        return this.entities.size() == 0;
+        return this.lockedOptiReadCode(()->{
+            return this.entities.size() == 0;
+        });
     }
 
     public void mergeInto(final ChunkEntitySlices slices) {
-        final Entity[] entities = this.entities.getRawData();
-        for (int i = 0, size = Math.min(entities.length, this.entities.size()); i < size; ++i) {
-            final Entity entity = entities[i];
-            slices.addEntity(entity, entity.sectionY);
-        }
+        this.lockedOptiReadCode(()->{
+            final Entity[] entities = this.entities.getRawData();
+            for (int i = 0, size = Math.min(entities.length, this.entities.size()); i < size; ++i) {
+                final Entity entity = entities[i];
+                slices.addEntity(entity, entity.sectionY);
+            }
+            return null;
+        });
     }
 
     private boolean preventStatusUpdates;
@@ -181,86 +223,106 @@ public final class ChunkEntitySlices {
     }
 
     public void updateStatus(final FullChunkStatus status, final EntityLookup lookup) {
-        this.status = status;
+        this.lockedOptiReadCode(()-> {
+            this.status = status;
 
-        final Entity[] entities = this.entities.getRawData();
+            final Entity[] entities = this.entities.getRawData();
 
-        for (int i = 0, size = this.entities.size(); i < size; ++i) {
-            final Entity entity = entities[i];
+            for (int i = 0, size = this.entities.size(); i < size; ++i) {
+                final Entity entity = entities[i];
 
-            final Visibility oldVisibility = EntityLookup.getEntityStatus(entity);
-            entity.chunkStatus = status;
-            final Visibility newVisibility = EntityLookup.getEntityStatus(entity);
+                final Visibility oldVisibility = EntityLookup.getEntityStatus(entity);
+                entity.chunkStatus = status;
+                final Visibility newVisibility = EntityLookup.getEntityStatus(entity);
 
-            lookup.entityStatusChange(entity, this, oldVisibility, newVisibility, false, false, false);
-        }
+                lookup.entityStatusChange(entity, this, oldVisibility, newVisibility, false, false, false);
+            }
+            return null;
+        });
     }
 
     public boolean addEntity(final Entity entity, final int chunkSection) {
-        if (!this.entities.add(entity)) {
-            return false;
-        }
-        entity.chunkStatus = this.status;
-        final int sectionIndex = chunkSection - this.minSection;
+        return this.lockedWriteCode(()->{
+            if (!this.entities.add(entity)) {
+                return false;
+            }
+            entity.chunkStatus = this.status;
+            final int sectionIndex = chunkSection - this.minSection;
 
-        this.allEntities.addEntity(entity, sectionIndex);
+            this.allEntities.addEntity(entity, sectionIndex);
 
-        if (entity.hardCollides()) {
-            this.hardCollidingEntities.addEntity(entity, sectionIndex);
-        }
+            if (entity.hardCollides()) {
+                this.hardCollidingEntities.addEntity(entity, sectionIndex);
+            }
 
-        for (final Iterator<Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection>> iterator =
-             this.entitiesByClass.reference2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
-            final Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection> entry = iterator.next();
+            for (final Iterator<Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection>> iterator =
+                 this.entitiesByClass.reference2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
+                final Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection> entry = iterator.next();
 
-            if (entry.getKey().isInstance(entity)) {
-                entry.getValue().addEntity(entity, sectionIndex);
+                if (entry.getKey().isInstance(entity)) {
+                    entry.getValue().addEntity(entity, sectionIndex);
+                }
             }
-        }
 
-        return true;
+            return true;
+        });
     }
 
     public boolean removeEntity(final Entity entity, final int chunkSection) {
-        if (!this.entities.remove(entity)) {
-            return false;
-        }
-        entity.chunkStatus = null;
-        final int sectionIndex = chunkSection - this.minSection;
+        return this.lockedWriteCode(()->{
+            if (!this.entities.remove(entity)) {
+                return false;
+            }
+            entity.chunkStatus = null;
+            final int sectionIndex = chunkSection - this.minSection;
 
-        this.allEntities.removeEntity(entity, sectionIndex);
+            this.allEntities.removeEntity(entity, sectionIndex);
 
-        if (entity.hardCollides()) {
-            this.hardCollidingEntities.removeEntity(entity, sectionIndex);
-        }
+            if (entity.hardCollides()) {
+                this.hardCollidingEntities.removeEntity(entity, sectionIndex);
+            }
 
-        for (final Iterator<Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection>> iterator =
-             this.entitiesByClass.reference2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
-            final Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection> entry = iterator.next();
+            for (final Iterator<Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection>> iterator =
+                 this.entitiesByClass.reference2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
+                final Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection> entry = iterator.next();
 
-            if (entry.getKey().isInstance(entity)) {
-                entry.getValue().removeEntity(entity, sectionIndex);
+                if (entry.getKey().isInstance(entity)) {
+                    entry.getValue().removeEntity(entity, sectionIndex);
+                }
             }
-        }
 
-        return true;
+            return true;
+        });
     }
 
     public void getHardCollidingEntities(final Entity except, final AABB box, final List<Entity> into, final Predicate<? super Entity> predicate) {
-        this.hardCollidingEntities.getEntities(except, box, into, predicate);
+        this.lockedOptiReadCode(()->{
+            this.hardCollidingEntities.getEntities(except, box, into, predicate);
+            return null;
+        });
     }
 
     public void getEntities(final Entity except, final AABB box, final List<Entity> into, final Predicate<? super Entity> predicate) {
-        this.allEntities.getEntitiesWithEnderDragonParts(except, box, into, predicate);
+        this.lockedOptiReadCode(()->{
+            this.allEntities.getEntitiesWithEnderDragonParts(except, box, into, predicate);
+            return null;
+        });
     }
 
     public void getEntitiesWithoutDragonParts(final Entity except, final AABB box, final List<Entity> into, final Predicate<? super Entity> predicate) {
-        this.allEntities.getEntities(except, box, into, predicate);
+        this.lockedOptiReadCode(()->{
+            this.allEntities.getEntities(except, box, into, predicate);
+            return null;
+        });
     }
 
     public <T extends Entity> void getEntities(final EntityType<?> type, final AABB box, final List<? super T> into,
                                                final Predicate<? super T> predicate) {
-        this.allEntities.getEntities(type, box, (List)into, (Predicate)predicate);
+        this.lockedOptiReadCode(()->{
+            this.allEntities.getEntities(type, box, (List)into, (Predicate)predicate);
+            return null;
+        });
+
     }
 
     protected EntityCollectionBySection initClass(final Class<? extends Entity> clazz) {
@@ -288,13 +350,16 @@ public final class ChunkEntitySlices {
 
     public <T extends Entity> void getEntities(final Class<? extends T> clazz, final Entity except, final AABB box, final List<? super T> into,
                                                final Predicate<? super T> predicate) {
-        EntityCollectionBySection collection = this.entitiesByClass.get(clazz);
-        if (collection != null) {
-            collection.getEntitiesWithEnderDragonParts(except, clazz, box, (List)into, (Predicate)predicate);
-        } else {
-            this.entitiesByClass.putIfAbsent(clazz, collection = this.initClass(clazz));
-            collection.getEntitiesWithEnderDragonParts(except, clazz, box, (List)into, (Predicate)predicate);
-        }
+        this.lockedOptiReadCode(()->{
+            EntityCollectionBySection collection = this.entitiesByClass.get(clazz);
+            if (collection != null) {
+                collection.getEntitiesWithEnderDragonParts(except, clazz, box, (List)into, (Predicate)predicate);
+            } else {
+                this.entitiesByClass.putIfAbsent(clazz, collection = this.initClass(clazz));
+                collection.getEntitiesWithEnderDragonParts(except, clazz, box, (List)into, (Predicate)predicate);
+            }
+            return null;
+        });
     }
 
     protected static final class BasicEntityList<E extends Entity> {
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 593463d540d69c3221d786b6862c8b14df57d52a..0c9c226eca0dd5f81de477905ac995ae5c280871 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -21,6 +21,8 @@ import java.util.function.Consumer;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
 
+import io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler;
+import io.papermc.paper.util.TickThread;
 import me.earthme.molia.thread.CraftSchedulerRunner;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
@@ -326,7 +328,10 @@ public class ServerChunkCache extends ChunkSource {
     }
     private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getChunkFutureMainThread(int chunkX, int chunkZ, ChunkStatus leastStatus, boolean create, boolean isUrgent) {
         // Paper start - rewrite chunk system
-        io.papermc.paper.util.TickThread.ensureTickThread(this.level, chunkX, chunkZ, "Scheduling chunk load off-main");
+        //Molia start - Remove this async catcher
+        //io.papermc.paper.util.TickThread.ensureTickThread(this.level, chunkX, chunkZ, "Scheduling chunk load off-main");
+        //Molia end
+
         int minLevel = ChunkLevel.byStatus(leastStatus);
         io.papermc.paper.chunk.system.scheduling.NewChunkHolder chunkHolder = this.level.chunkTaskScheduler.chunkHolderManager.getChunkHolder(chunkX, chunkZ);
 
@@ -348,11 +353,19 @@ public class ServerChunkCache extends ChunkSource {
                 }
             };
 
-            this.level.chunkTaskScheduler.scheduleChunkLoad(
-                chunkX, chunkZ, leastStatus, true,
-                isUrgent ? ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.BLOCKING : ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.NORMAL,
-                complete
-            );
+            //Molia start - Fix schedule chunk load off main error
+            if (!TickThread.isTickThreadFor(this.level, chunkX, chunkZ)) {
+                this.level.chunkTaskScheduler.scheduleChunkTask(chunkX, chunkZ, () -> {
+                    this.level.chunkTaskScheduler.scheduleChunkLoad(chunkX, chunkZ,  leastStatus, true,isUrgent ? ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.BLOCKING : ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.NORMAL ,complete);
+                } ,isUrgent ? ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.BLOCKING : ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.NORMAL);
+            }else{
+                this.level.chunkTaskScheduler.scheduleChunkLoad(
+                        chunkX, chunkZ, leastStatus, true,
+                        isUrgent ? ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.BLOCKING : ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.NORMAL,
+                        complete
+                );
+            }
+            //Molia end
 
             return ret;
         } else {
